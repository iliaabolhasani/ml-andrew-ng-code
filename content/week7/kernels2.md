---
title: "کرنل ها قسمت دوم"
date: 2020-11-17T16:40:46+03:30
draft: false
weight: 50
---

یکی از راه های بدست آوردن نقطه های عطف این است که آن ها را دقیقا در مکان همه نمونه های آموزشی قرار دهیم. این کار به ما m نقطه عطف می دهد، با یک نقطه عطف به ازای هر نمونه آموزشی.

با توجه به x:

$$
f_1=similarity(x,l^{(1)}),\hspace{0.1cm} f_2=similarity(x,l^{(2)}),\hspace{0.1cm}f_3=similarity(x,l^{(3)}),...
$$

این به ما یک «بردار ویژگی» می دهد، $f_{(i)}$ همه ویژگی های ما برای نمونه $x_{(i)}$. هم چنین می توانیم $f_0=1$ قرار دهیم تا مطابق با $\Theta_0$ شود. بنابراین با توجه به نمونه $x_{(i)}$ داریم:

$$
x^{(i)} \rightarrow
\begin{bmatrix}
f_1^{(i)}=similarity(x^{(i)},l^{(1)})
\newline
f_2^{(i)}=similarity(x^{(i)},l^{(2)})
\newline
.
\newline
.
\newline
.
\newline
f_m^{(i)}=similarity(x^{(i)},l^{(m)})
\end{bmatrix}
$$

حالا برای بدست آوردن پارامترهای $\Theta$ می توانیم از الگوریتم مینیمم سازی ماشین بردار پشتیبان استفاده کنیم اما با $f^{(i)}$ جایگزین شده برای \$x^{(i)}\$:

$$
min_\Theta C\sum_{i=1}^{m}y^{(i)}cost_1(\Theta^Tf^{(i)})+(1-y^{(i)})cost_0(\theta^Tf^{(i)})+\frac{1}{2}\sum_{j=1}^{n}\Theta_j^2
$$

استفاده از کرنل ها برای ایجاد $f(i)$
تنها منحصر به ماشین های بردار پشتیبان نیست و می تواند روی رگریسیون لجستیک هم اعمال شود. اگرچه، به دلیل
بهینه سازی های محاسباتی روی ماشین های بردار پشتیبان،
کرنل های ترکیب شده با ماشین های بردار پشتیبان بسیار سریع تر از ترکیب با الگوریتم های دیگر است، بنابراین کرنل ها اغلب همیشه تنها به صورت ترکیب شده
با ماشین های بردار پشتیبان یافت می شوند.

**انتخاب پارامترهای ماشین بردار پشتیبان**

انتخاب C (به خاطر بیاورید که $C=\frac{1}{\lambda}$)

- اگر C بزرگ باشد، آن گاه واریانس بزرگتر/ بایاس کوچکتر به دست می آوریم.
- اگر C کوچک باشد، آن گاه واریانس کوچکتر/ بایاس بزرگتر به دست می آوریم.

پارامتر دیگری که باید انتخاب کنیم $\sigma^2$ از تابع کرنل گواسی است:

با داشتن $\sigma^2$ بزرگتر، ویژگی های fi با نرمی بیشتری تغییر می کنند که باعث بایاس بزرگتر و واریانس کوچکتر می شود.

با داشتن $\sigma^2$ کوچکتر، ویژگی های fi با نرمی کمتری تغییر می کنند که باعث بایاس کوچکتر و واریانس بزرگتر می شود.

**استفاده از یک ماشین بردار پشتیبان**

تا الان کتابخانه های خوب زیادی برای ماشین بردار پشتیبان نوشته شده است. A.Ng معمولا از liblinear و libsvm استفاده می کند.
در کاربرد عملی، شما باید به جای دوباره نویسی تابع ها از یکی از این
کتابخانه ها استفاده کنید.

در کاربرد عملی، انتخاب هایی که باید انجام دهید عبارتند از:

- انتخاب پارامتر C
- انتخاب کرنل (تابع شباهت)
- بدون کرنل (کرنل «خطی»)-- یک طبقه بندی کننده استاندارد را به ما می دهد
- انتخاب کنید وقتی که n بزرگ و m کوچک است
- کرنل گواسی (در بالا آمده است) -- نیاز است که $\sigma^2$ راانتخاب کنید
- انتخاب کنید وقتی که n کوچک و m بزرگ است

کتابخانه ممکن است از شما بخواهد تا تابع کرنل را فراهم کنید.

**نکته:**
قبل از استفاده از کرنل گواسی، feature scaling را انجام دهید.

**نکته:**
همه ی تابع های شباهت، کرنل های معتبری نیستند.
آن ها باید «قضیه Mercer» را ارضا کنند که ضمانت می کند که بهینه سازی های پکیج های ماشین بردار پشتیبان ، درست عمل کنند و اختلاف پیدا نکنند.

شما می خواهید که با استفاده از مجموعه داده های آموزشی و اعتبارسنجی متقابل، C و پارامترها را برای تابع کرنل تعلیم دهید.

**طبقه بندی کننده چندکلاسه**

بسیاری از کتابخانه های ماشین بردار پشتیبان، درون خود، طبقه بندی کننده چندکلاسه دارند.

شما می توانید از متود «یک در مقابل همه» استفاده کنید مانند کاری که ما در رگریسیون لجستیک انجام دادیم، جایی که $y\in 1,2,3,...,k$ با $\Theta^{(1)},\Theta^{(2)},...,\Theta^{(k)}$. ما کلاس i را که دارای بزرگترین $(\Theta^{(i)})^Tx$
است
انتخاب می کنیم.

**رگریسیون لجستیک در مقابل ماشین های بردار پشتیبان**

اگر n بزرگ است (در مقایسه با m)،
آنگاه از رگریسیون لجستیک استفاده کنید، یا از ماشین بردار پشتیبان بدون کرنل («کرنل خطی»).

اگر n کوچک و m متوسط است، آنگاه از ماشین بردار پشتیبان با کرنل گواسی استفاده کنید.

اگر n کوچک و m بزرگ است. آنگاه به صورت دستی ویژگی های بیشتری را ایجاد/اضافه کنید، سپس از رگریسیون لجستیک یا ماشین بردار پشتیبان بدون کرنل استفاده کنید.

در اولین مورد، ما مثال های کافی و موردنیاز برای یک فرضیه چند جمله ای پیچیده در اختیار نداریم.
درمورد دوم، ما مثال های کافی داریم که ممکن است به یک فرضیه پیچیده غیرخطی نیاز داشته باشیم.
در مورد آخر، ما می خواهیم که ویژگی هایمان را افزایش دهیم تا رگریسیون لجستیک قابل اجرا شود.

**نکته:**
یک شبکه عصبی به احتمال زیاد برای هر یک از این شرایط به خوبی کار می کند، اما ممکن است آموزش آن کندتر باشد.
